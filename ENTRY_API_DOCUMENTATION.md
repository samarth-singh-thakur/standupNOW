# StandupNow Entry API Documentation

Standard format for entries shared between Chrome Extension and Android App.

## Entry Schema

```javascript
{
  // Core fields
  "id": "uuid-v4",                          // Unique ID (generated by phone)
  "time": "2026-02-17T11:12:53.652Z",      // ISO 8601 UTC timestamp
  "note": "Completed API documentation",    // Entry content
  
  // Sync fields
  "createdAt": "2026-02-17T11:12:53.652Z", // Creation time (immutable)
  "updatedAt": "2026-02-17T11:12:53.652Z", // Last update time
  "version": 1,                             // Increments on each edit
  "deleted": false                          // Soft delete flag
}
```

## Field Rules

| Field | Type | Description |
|-------|------|-------------|
| `id` | UUID v4 | Generated by Android phone (primary server) |
| `time` | ISO 8601 | When entry was created |
| `note` | String | Entry content (1-5000 chars) |
| `createdAt` | ISO 8601 | Original creation time (never changes) |
| `updatedAt` | ISO 8601 | Last modification time |
| `version` | Integer | Starts at 1, increments on updates |
| `deleted` | Boolean | `true` = soft deleted, `false` = active |

## Creating Entries

### On Android (Primary Server)

```javascript
function createEntry(noteText) {
  return {
    id: generateUUID(),
    time: new Date().toISOString(),
    note: noteText.trim(),
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    version: 1,
    deleted: false
  };
}
```

### On Extension (Client)

```javascript
async function createEntry(noteText) {
  const entry = {
    id: crypto.randomUUID(),
    time: new Date().toISOString(),
    note: noteText.trim(),
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    version: 1,
    deleted: false
  };
  
  // Save locally
  const data = await chrome.storage.local.get("entries");
  const entries = data.entries || [];
  entries.unshift(entry);
  await chrome.storage.local.set({ entries });
  
  // Sync to phone
  await syncToPhone(entry);
  
  return entry;
}
```

## Updating Entries

```javascript
function updateEntry(entry, newNote) {
  entry.note = newNote.trim();
  entry.updatedAt = new Date().toISOString();
  entry.version += 1;
  return entry;
}
```

## Soft Delete

```javascript
function deleteEntry(entry) {
  entry.deleted = true;
  entry.updatedAt = new Date().toISOString();
  entry.version += 1;
  return entry;
}
```

## Sync Protocol

### Extension → Phone (Push)

```javascript
POST /api/sync/push
Headers: {
  "Authorization": "Bearer <token>",
  "Content-Type": "application/json"
}
Body: {
  "entries": [/* new/updated entries */],
  "lastSyncTime": "2026-02-17T11:00:00.000Z"
}
```

### Phone → Extension (Pull)

```javascript
GET /api/sync/pull?since=2026-02-17T11:00:00.000Z
Headers: {
  "Authorization": "Bearer <token>"
}
Response: {
  "entries": [/* all entries updated since timestamp */],
  "serverTime": "2026-02-17T11:15:00.000Z"
}
```

## Conflict Resolution

**Phone Always Wins** - Phone is the source of truth.

```javascript
function resolveConflict(phoneEntry, extensionEntry) {
  // Compare versions
  if (phoneEntry.version > extensionEntry.version) {
    return phoneEntry; // Phone wins
  }
  
  // Same version, compare timestamps
  if (new Date(phoneEntry.updatedAt) >= new Date(extensionEntry.updatedAt)) {
    return phoneEntry; // Phone wins
  }
  
  return phoneEntry; // Phone always wins
}
```

## Extension Sync Implementation

```javascript
async function syncWithPhone(apiUrl, token) {
  try {
    // Get local entries
    const data = await chrome.storage.local.get(["entries", "lastSyncTime"]);
    const localEntries = data.entries || [];
    const lastSync = data.lastSyncTime || new Date(0).toISOString();
    
    // Pull from phone
    const response = await fetch(`${apiUrl}/sync/pull?since=${lastSync}`, {
      headers: { "Authorization": `Bearer ${token}` }
    });
    const { entries: phoneEntries, serverTime } = await response.json();
    
    // Merge: Phone entries override local
    const merged = mergeEntries(localEntries, phoneEntries);
    
    // Save
    await chrome.storage.local.set({ 
      entries: merged,
      lastSyncTime: serverTime
    });
    
    return { success: true, synced: phoneEntries.length };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

function mergeEntries(local, phone) {
  const map = new Map();
  
  // Add local entries
  local.forEach(e => map.set(e.id, e));
  
  // Phone entries override
  phone.forEach(e => map.set(e.id, e));
  
  // Sort by time (newest first), filter deleted
  return Array.from(map.values())
    .filter(e => !e.deleted)
    .sort((a, b) => new Date(b.time) - new Date(a.time));
}
```

## Shared Authentication

Both extension and Android app use same auth token.

```javascript
// Login (both platforms)
POST /api/auth/login
Body: {
  "email": "user@example.com",
  "password": "password"
}
Response: {
  "token": "jwt-token",
  "expiresAt": "2026-02-18T11:00:00.000Z"
}

// Store token
// Extension: chrome.storage.local.set({ authToken: token })
// Android: SharedPreferences or secure storage
```

## Export/Import Format

```json
{
  "version": "2.0",
  "exportDate": "2026-02-17T11:12:53.652Z",
  "entries": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "time": "2026-02-17T11:12:53.652Z",
      "note": "Entry content",
      "createdAt": "2026-02-17T11:12:53.652Z",
      "updatedAt": "2026-02-17T11:12:53.652Z",
      "version": 1,
      "deleted": false
    }
  ]
}
```

## Migration from Old Format

```javascript
async function migrateEntries() {
  const data = await chrome.storage.local.get("entries");
  const entries = data.entries || [];
  
  const migrated = entries.map(entry => {
    if (entry.id) return entry; // Already migrated
    
    return {
      id: crypto.randomUUID(),
      time: entry.time,
      note: entry.note,
      createdAt: entry.time,
      updatedAt: entry.time,
      version: 1,
      deleted: false
    };
  });
  
  await chrome.storage.local.set({ entries: migrated });
}
```

## Best Practices

1. **Phone is Primary**: Always trust phone data over extension
2. **Sync Frequently**: Sync every 5-15 minutes or on user action
3. **Handle Offline**: Queue changes when offline, sync when online
4. **Validate Data**: Check all fields before saving
5. **Secure Token**: Store auth token securely on both platforms

---

**Version:** 2.0 (2026-02-17)